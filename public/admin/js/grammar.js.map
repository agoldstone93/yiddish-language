{
  "version": 3,
  "sources": ["../../../src/lib/grammar/auxiliaries.ts", "../../../src/lib/grammar/past.ts", "../../../src/lib/grammar/future.ts", "../../../src/lib/grammar/imperative.ts", "../../../src/lib/grammar/browser.ts"],
  "sourcesContent": ["import { Person, VerbForm } from '@/types/verb';\n\nexport const auxiliaries: Record<\n  'zayn' | 'hobn',\n  Record<Person, VerbForm>\n> = {\n  zayn: {\n    ikh: { yiddish: '\u05D1\u05D9\u05DF', transliteration: 'bin' },\n    du: { yiddish: '\u05D1\u05D9\u05E1\u05D8', transliteration: 'bist' },\n    er_zi_es: { yiddish: '\u05D0\u05D9\u05D6', transliteration: 'iz' },\n    mir: { yiddish: '\u05D6\u05F2\u05B7\u05E0\u05E2\u05DF', transliteration: 'zaynen' },\n    ir: { yiddish: '\u05D6\u05F2\u05B7\u05D8', transliteration: 'zayt' },\n    zey: { yiddish: '\u05D6\u05F2\u05B7\u05E0\u05E2\u05DF', transliteration: 'zaynen' },\n  },\n  hobn: {\n    ikh: { yiddish: '\u05D4\u05D0\u05B8\u05D1', transliteration: 'hob' },\n    du: { yiddish: '\u05D4\u05D0\u05B8\u05E1\u05D8', transliteration: 'host' },\n    er_zi_es: { yiddish: '\u05D4\u05D0\u05B8\u05D8', transliteration: 'hot' },\n    mir: { yiddish: '\u05D4\u05D0\u05B8\u05D1\u05DF', transliteration: 'hobn' },\n    ir: { yiddish: '\u05D4\u05D0\u05B8\u05D8', transliteration: 'hot' },\n    zey: { yiddish: '\u05D4\u05D0\u05B8\u05D1\u05DF', transliteration: 'hobn' },\n  },\n};\n", "import { Verb, Person, VerbForm } from '@/types/verb';\nimport { auxiliaries } from './auxiliaries';\n\nexport function getPastForms(\n  verb: Verb\n): Record<Person, VerbForm> | null {\n  if (!verb.conjugation) return null;\n  const pp = verb.conjugation.past_participle;\n  if (!pp) return null;\n\n  const aux = auxiliaries[verb.auxiliary];\n  const result = {} as Record<Person, VerbForm>;\n\n  (Object.keys(aux) as Person[]).forEach((person) => {\n    const yiddishZikh = verb.reflexive ? ' \u05D6\u05D9\u05DA' : '';\n    const transliterationZikh = verb.reflexive ? ' zikh' : '';\n    const ppYiddish = verb.reflexive\n      ? pp.yiddish.replace(/\\s?\u05D6\u05D9\u05DA$/, '')\n      : pp.yiddish;\n    const ppTranslit = verb.reflexive\n      ? pp.transliteration.replace(/\\s?zikh$/, '')\n      : pp.transliteration;\n    result[person] = {\n      yiddish: `${aux[person].yiddish}${yiddishZikh} ${ppYiddish}`,\n      transliteration: `${aux[person].transliteration}${transliterationZikh} ${ppTranslit}`,\n    };\n  });\n\n  return result;\n}\n", "import { Verb, Person, VerbForm } from '@/types/verb';\n\nexport const velnPresent: Record<Person, VerbForm> = {\n  ikh: { yiddish: '\u05D5\u05D5\u05E2\u05DC', transliteration: 'vel' },\n  du: { yiddish: '\u05D5\u05D5\u05E2\u05E1\u05D8', transliteration: 'vest' },\n  er_zi_es: { yiddish: '\u05D5\u05D5\u05E2\u05D8', transliteration: 'vet' },\n  mir: { yiddish: '\u05D5\u05D5\u05E2\u05DC\u05DF', transliteration: 'veln' },\n  ir: { yiddish: '\u05D5\u05D5\u05E2\u05D8', transliteration: 'vet' },\n  zey: { yiddish: '\u05D5\u05D5\u05E2\u05DC\u05DF', transliteration: 'veln' },\n};\n\nexport function getFutureForms(\n  verb: Verb\n): Record<Person, VerbForm> {\n  const result = {} as Record<Person, VerbForm>;\n\n  (Object.keys(velnPresent) as Person[]).forEach((person) => {\n    let lemmaYiddish = verb.lemma.yiddish;\n    let lemmaTranslit = verb.lemma.transliteration;\n    \n    // For reflexive verbs, zikh should come after vel, not at the end of lemma\n    if (verb.reflexive && lemmaYiddish.includes(' \u05D6\u05D9\u05DA')) {\n      lemmaYiddish = lemmaYiddish.replace(' \u05D6\u05D9\u05DA', '');\n      lemmaTranslit = lemmaTranslit.replace(' zikh', '');\n    }\n    \n    const yiddishZikh = verb.reflexive ? ' \u05D6\u05D9\u05DA' : '';\n    const transliterationZikh = verb.reflexive ? ' zikh' : '';\n    \n    result[person] = {\n      yiddish: `${velnPresent[person].yiddish}${yiddishZikh} ${lemmaYiddish}`,\n      transliteration: `${velnPresent[person].transliteration}${transliterationZikh} ${lemmaTranslit}`,\n    };\n  });\n\n  return result;\n}\n", "import { Verb, VerbForm } from '@/types/verb';\n\nexport function getImperativeForms(\n  verb: Verb\n): Partial<Record<'du' | 'ir', VerbForm>> | null {\n  if (!verb.conjugation) return null;\n  \n  // Explicit imperative (only zayn)\n  if (verb.conjugation.imperative) {\n    return verb.conjugation.imperative;\n  }\n\n  const { present } = verb.conjugation;\n  if (!present?.ikh || !present.ir) return null;\n\n  return {\n    du: present.ikh,\n    ir: present.ir,\n  };\n}\n", "// Browser entry point for grammar functions\n// This file is compiled to public/admin/js/grammar.js for use in CMS preview\n\nimport { getPastForms } from './past';\nimport { getFutureForms, velnPresent } from './future';\nimport { getImperativeForms } from './imperative';\nimport { auxiliaries } from './auxiliaries';\nimport type { Person } from '@/types/verb';\n\nconst persons: Person[] = [\"ikh\", \"du\", \"er_zi_es\", \"mir\", \"ir\", \"zey\"];\n\n// Expose to window for CMS preview\ndeclare global {\n  interface Window {\n    VerbGrammar: {\n      auxiliaries: typeof auxiliaries;\n      velnPresent: typeof velnPresent;\n      persons: typeof persons;\n      getPastForms: typeof getPastForms;\n      getFutureForms: typeof getFutureForms;\n      getImperativeForms: typeof getImperativeForms;\n    };\n  }\n}\n\nwindow.VerbGrammar = {\n  auxiliaries,\n  velnPresent,\n  persons,\n  getPastForms,\n  getFutureForms,\n  getImperativeForms,\n};\n"],
  "mappings": "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",
  "names": []
}
